数据结构
数据结构：数据存储于内存时，决定了数据顺序和位置关系的便是“数据结构”
链表：每个数据都有1个“指针”，它指向下一个数据的内存地址，访问数据O(n),添加和删除O(1)
数组：数据按顺序存储在内存的连续空间内，每个数据的内存地址（在内存上的位置）都可以通过数组下标算出，访问数据O(1),添加和删除O(n)
栈：栈最后添加的数据最先被取出，即“后进先出”结构，称为Last In First Out，简称LIFO
队列：最先进去的数据最先被取来，即“先进先出”的结构，称为First In First Out，简称FIFO
哈希表：哈希表存储的是由键（key）和值（value）组成的数据，在哈希表中，可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储
堆：堆是一种图的树形结构，被用于实现“优先队列”
    优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中
    结点的排列顺序为从上到下，同一行里则为从左到右；堆中的每个结点最多有两个子结点；子结点必定大于父结点，如果父结点大于子结点，则需要交换父子结点的位置
    堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为O（1）；添加数据需要的运行时间与树的高度成正比，是O（logn），重构树的时间复杂度为O（logn）。
二叉查找树: 是一种数据结构, 数据存储于二叉查找树的各个结点中;
           二叉查找树有两个性质:第一个是每个结点的值均大于其左子树上任意一个结点的值,第二个是每个结点的值均小于其右子树上任意一个结点的值

排序
冒泡排序：从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置；第一轮结束之后最小的数被换到了最左边
         在冒泡排序中，第1轮需要比较n-1次，第2轮需要比较n-2次……第n-1轮需要比较1次。因此，总的比较次数为（n-1）+（n-2）+…+1≈n2/2
选择排序：选择排序就是重复“从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换”这一操作的算法。在序列中寻找最小值时使用的是线性查找。  
         选择排序使用了线性查找来寻找最小值，因此在第1轮中需要比较n-1个数字，第2轮需要比较n-2个数字……到第n-1轮的时候就只需比较1个数字了。
         因此，总的比较次数与冒泡排序的相同，都是（n-1）+（n-2）+…+1≈n2/2次。
插入排序：是一种从序列左端开始依次对数据进行排序的算法。在排序过程中，左侧的数据陆续归位，而右侧留下的就是还未被排序的数据。    
         如果取出的数字比左边已归位的数字都要小，就必须不停地比较大小，交换数字，直到它到达整个序列的最左边为止。
         具体来说，就是第k轮需要比较k-1次。因此，在最糟糕的情况下，第2轮需要操作1次，第3轮操作2次……第n轮操作n-1次，所以时间复杂度和冒泡排序的一样，都为O（n2）。
堆排序：堆排序一开始需要将n个数据存进堆里，所需时间为O（nlogn）
       每轮取出最大的数据并重构堆所需要的时间为O（logn）。由于总共有n轮，所以重构后排序的时间也是O（nlogn）。因此，整体来看堆排序的时间复杂度为O（nlogn）。
归并排序：归并排序算法会把序列分成长度相同的两个子序列，当无法继续往下分时（也就是每个子序列中只有一个数据时），就对子序列进行归并。
         归并指的是把两个排好序的子序列合并成一个有序序列。该操作会一直重复执行，直到所有子序列都归并为一个整体为止。
         归并排序中，分割序列所花费的时间不算在运行时间内（可以当作序列本来就是分割好的），无论哪一行都是n个数据，所以每行的运行时间都为O（n）。
         而将长度为n的序列对半分割直到只有一个数据为止时，可以分成log2n行，因此，总共有log2n行。也就是说，总的运行时间为O（nlogn）
快速排序：快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。
         [比基准值小的数] 基准值 [比基准值大的数]接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序。
         每行中每个数字都需要和基准值比较大小，因此每行所需的运行时间为O（n）
